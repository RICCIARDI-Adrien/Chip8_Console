#
# Octogon Trail
# October 2022, 2023
# tarsi
#

##################################################
# Utility
##################################################
#
#
# Test animation, modes
# - minimum 500 cycles/frame for smooth animation
#

# sync - variable delay for smooth animation, independent of cycles/frame
: sync
 loop
  vf := delay
  if vf != 0 then
 again

 # delay for up to 1/60th of a second
 # using the fixed-rate delay timer
 vf := 10
 delay := vf
;

# Simple delay to be used in transitions
 : sp_delay
    # v0 - delay in seconds
    v1 := 0
    delay := v1
    loop
        v1 := delay
        if v1 == 0 begin
            if v0 != 0 begin
                v0 -= 1
                v1 := 60
                delay := v1
            end
        end
        if v1 != 0 then 
    again
    return

##################################################
# Sound
##################################################

#: click
#    0x02 0xCD 0x00 0x00 0x00 0x00 0x00 0x00
#    0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
#: note_C 0xCF 0xC0 0x59 0x8D 0xCC 0x4F 0xF3 0x63 0xD4 0xE0 0x00 0x00 0x00 0x00 0x00 0x00
#: pitch_C 222
#: note_D 0xF4 0xF1 0x53 0x7D 0x3C 0x8A 0xA0 0x93 0xA7 0x20 0x00 0x00 0x00 0x00 0x00 0x00
#: pitch_D 230
#: note_E 0xF4 0xF1 0x53 0x7D 0x3C 0x8A 0xA0 0x93 0xA7 0x20 0x00 0x00 0x00 0x00 0x00 0x00
#: pitch_E 238
# Experiment with sound
# : sp_buzz
#    # v0 - delay in seconds
#    # v2 - buzzer val each second
#    # v3 - note
#
#    #i := click
#    if v3 == 0 then i := note_C
#    if v3 == 0 then v4 := 222
#
#    if v3 == 1 then i := note_D
#    if v3 == 1 then v4 := 230
#
#    if v3 == 2 then i := note_E
#    if v3 == 2 then v4 := 238
#
#    if v3 == 3 then i := note_E
#    if v3 == 3 then v4 := 242
#
#    if v3 == 4 then i := note_E
#    if v3 == 4 then v4 := 250
#    audio
#    pitch := v4
#
#    v1 := 0
#    delay := v1
#    loop
#        v1 := delay
#        if v1 == 0 begin
#            if v0 != 0 begin
#                v0 -= 1
#                v1 := 21
#                delay := v1
#                v1 := v2
#                buzzer := v1
#            end
#        end
#        if v1 != 0 then
#    again
#    return

##################################################
# Constants
##################################################

:const TITLE_MODE       0
:const TRAVELING_MODE   1
:const HUNTING_MODE     2
:const HARDSHIP_MODE    3
:const GAME_OVER_MODE   4
:const UI_MODE          5

:const PACE_STOPPED  0
:const PACE_SLOW     1
:const PACE_MED      2
:const PACE_GRUELING 3

:const RATIONS_NONE 0
:const RATIONS_LOW  1
:const RATIONS_MED  2
:const RATIONS_HIGH 3

:const GAME_SETTINGS_PACE       0
:const GAME_SETTINGS_RATIONS    1
:const GAME_SETTINGS_REST       2
:const GAME_SETTINGS_NUM        3

# Game counter is the length of the trail.
# Tip: LOW_SIZE can be adjusted to make the game very brief or to
# extend the gameplay into a longer simulation like the original.
# Probably best to keep games short until a fun balance is achieved.
#:const GAME_COUNTER_LOW_SIZE 10    # Quick - ~1m30s
:const GAME_COUNTER_LOW_SIZE 20    # CHIP8 - ~3 mins
#:const GAME_COUNTER_LOW_SIZE 40     # Retail experience - ~5 mins
:const GAME_COUNTER_HIGH_SIZE 56

:const FRAMES_PER_DAY 16

##################################################
# Global variables
# - Overall game state
##################################################

: score         0
: game_counter  0 0     # distance
: days_elapsed  0 0     # time
: num_dollars   0 0
: num_meat      0 0
: num_bullets   0
: num_oxen      0
: num_wheels    0
: party_alive   0       # proxy for detailed party info
: party_health  0       # num_sick = alive - health
: party_dead    0
: travel_pace   0
: rations       0
: curr_mode     0

: END_OF_GLOBALS

##################################################
# Game reset
# - Set initial values of memory
##################################################
: reset_game
    v8 := 0
    v9 := 0
    i := game_counter
    save v8 - v9

    i := days_elapsed
    save v8 - v9

    i := num_dollars
    v6 := 0
    v7 := 100
    save v6 - v7

    i := num_meat
    v6 := 0
    v7 := 100
    v7 := 1 # temporary!!!!!!
    save v6 - v7

    i := num_bullets
    v7 := 50
    save v7 - v7

    i := num_oxen
    v7 := 2
    save v7 - v7

    i := num_wheels
    v7 := 2
    save v7 - v7

    i := party_alive
    #v7 := 0b00111111           # Does not work because computations are done with the size not the bitfield
    v7 := 6
    save v7 - v7

    i := party_health
    v7 := 6
    save v7 - v7

    i := party_dead
    v7 := 0
    save v7 - v7

    i := num_wheels
    v7 := 2
    save v7 - v7

    v7 := PACE_MED
    i := travel_pace
    save v7 - v7

    v7 := RATIONS_MED
    i := rations
    save v7 - v7

    v8 := TITLE_MODE
    i := curr_mode
    save v8 - v8
    reset_title_mode

    return

##################################################
# Main loop
# - Dispatch to active game state
##################################################
# Main loop ---------------------------------------

: main
    reset_game

    loop
        # dispatch
        # TODO: replace with jump0 table???
        i := curr_mode
        load v8 - v8
        if v8 == TRAVELING_MODE begin loop_traveling_mode
        else if v8 == HUNTING_MODE begin loop_hunting_mode
#            else if v8 == HARDSHIP_MODE begin loop_hardship_mode
				else if v8 == UI_MODE begin loop_ui_mode
		            else if v8 == GAME_OVER_MODE begin loop_game_over_mode
		                else if v8 == TITLE_MODE begin loop_title_mode
		                    end
		                end
		            end
				end
#            end
        end

    again

##################################################
# Title screen mode w/song
##################################################
: reset_title_mode
    clear

    # image
    v0 := 0
    v1 := 0
    v2 := 64
    v3 := 32
    v4 := 8
    i := title_img
    draw_img

    return

: loop_title_mode
    # user input
    vf := 0
    ve := OCTO_KEY_W if ve key then vf := OCTO_KEY_W  # Perhaps provide "hot keys" for async events like hunting
    #ve := OCTO_KEY_A if ve key then vf := OCTO_KEY_A
    #ve := OCTO_KEY_S if ve key then vf := OCTO_KEY_S
    #ve := OCTO_KEY_D if ve key then vf := OCTO_KEY_D

    # wait until the user presses start
    if vf == OCTO_KEY_W begin
        v8 := TRAVELING_MODE
        i := curr_mode
        save v8 - v8

        :call reset_traveling_mode
        return  # return and mode2 will execute
    end

    return


##################################################
# Normal traveling mode
# - Advance toward destination
# - TODO: Advance time... travel slows in the winter
# - TODO: Predetermined sequence of challenges
# - TODO: Random events such as illness and theft(?)
# - TODO: Initiate optional hunting/trading UI
# - TODO: Menu for changing game properties(?) like rations
# - Enter game over state after journey is completed or failed
##################################################

# Temporary variables used in traveling mode
#
: rolling_anim_index
3
: river_event_odds_per_256
4
: health_event_odds_per_256
20
: food_consumption_rate
10

# Setup/reset traveling mode
#
: reset_traveling_mode
    v8 := 0
    i := rolling_anim_index
    save v8 - v8
	
    v8 := 4 	# 4 * 256
    i := river_event_odds_per_256
    save v8 - v8

    v8 := 20	# 20 * 256
    i := health_event_odds_per_256
    save v8 - v8

    v8 := 10	# 10 units per day
    i := food_consumption_rate
    save v8 - v8

    clear

    # Draw initial cart
    i := small_cart
    v0 := 32
    v1 := 14
    sprite v0 v1 15
    v3 := 15
    i += v3
    v0 += 8
    sprite v0 v1 15
    i += v3
    v0 += 8
    sprite v0 v1 15

    i := wheel_frames_xor
    v0 := 37
    v1 += 8
    sprite v0 v1 8
    v0 += 10
    sprite v0 v1 8

    # Draw initial party info
    v0 := 0
    v1 := 2
    v2 := 28
    i := party_alive
    load v6 - v6
    i := party_health
    load v7 - v7
    loop
        i := img_person_sick
        if v0 < v7 then i := img_person_healthy
        # draw
        sprite v1 v2 4
        v1 += 5
        v0 += 1
        if v0 < v6 then
    again
    i := party_dead
    load v8 - v8
    if v8 > 0 begin
        i := img_person_dead
        v0 := 0
        loop
            # draw
            sprite v1 v2 4
            v1 += 5
            v0 += 1
            if v0 < v8 then
        again
    end

    draw_travel_animation

    return

: draw_travel_animation
    # Draw initial progress position
    v0 := 0
    i := game_counter
    load v8 - v9
    i := cart2
    sprite v9 v0 6

    v0 := 7
    i := days_elapsed
    load v6 - v7
    i := cart2
    sprite v7 v0 6

    # Draw inventory stats - dollars, meat, oxen, wheels, bullets
    i := num_meat
    load v6 - v7
    v6 >>= v6
    if v7 >= 1 then v6 := 24
    if v6 >= 24 then v6 := 24
    v7 := v6
    v0 := 2
    v1 := 14
    draw_stat
		
    i := num_dollars
    load v6 - v7
    v6 >>= v6
    if v7 >= 1 then v6 := 24
    if v6 >= 24 then v6 := 24
    v7 := v6
    v0 := 2
    v1 := 16
    draw_stat
		
    i := num_bullets
    load v7
    v0 := 2
    v1 := 18
    draw_stat

    i := days_elapsed
    load v6 - v7
    v7 := v6
    v0 := 2
    v1 := 20
    draw_stat
    return

# Traveling mode loop
#
: loop_traveling_mode

    # user input
    vf := 0
    ve := OCTO_KEY_W if ve key then vf := OCTO_KEY_W  # Perhaps provide "hot keys" for async events like hunting
    ve := OCTO_KEY_A if ve key then vf := OCTO_KEY_A
#    ve := OCTO_KEY_S if ve key then vf := OCTO_KEY_S
    ve := OCTO_KEY_D if ve key then vf := OCTO_KEY_D

    if vf == OCTO_KEY_D begin
        # switch mode - e.g. hunting
        v8 := HUNTING_MODE
        i := curr_mode
        save v8 - v8

        reset_hunting_mode
        return
    end
#    if vf == OCTO_KEY_S begin
#        v8 := HARDSHIP_MODE
#        i := curr_mode
#        save v8 - v8
#
#        reset_hardship_mode
#        return
#    end
    if vf == OCTO_KEY_A begin
        v8 := UI_MODE
        i := curr_mode
        save v8 - v8

        reset_ui_mode
        return
    end

    # logic
    # - roll the dice for random events

    # At the end of a frame:
    # - Advance time
    # - Travel forward
    # - Deplete the food
    # - Progress health conditions 
    i := game_counter
    load v8 - v9

    # Erase
    draw_travel_animation

    :monitor num_meat 2
    :monitor num_dollars 2
    :monitor num_bullets 1
    :monitor days_elapsed 2
    :monitor num_wheels 1
    :monitor num_oxen 1
    :monitor rations 1
    :monitor travel_pace 1
    :monitor party_alive 1
    :monitor party_health 1
    :monitor party_dead 1

    # Advance time
    i := days_elapsed
    load v6 - v7
    v6 += 1
    save v6 - v7
    if v6 >= FRAMES_PER_DAY begin
        v7 += 1
        v6 -= FRAMES_PER_DAY
        save v6 - v7

        # TODO: Feed the party - need "MED" units per party member per day
        i := num_meat
        load v4 - v5
        i := party_alive
        load v3 - v3
        i := rations
        load v2 - v2

        # v1 is "food safety" - Get safety points based on rationing, but lose points if meat is insufficient
        v1 := v2

        if v2 > 0 begin
            loop
                if v4 < v3 begin    # Subtract the party size
                    if v5 == 0 begin
                        # Not enough meat, raise risk level!
                        v4 := 0
                        v1 -= 1
                    else
                        v5 -= 1
                        v4 += 100 # TODO: need better handling of 16-byte meat variable! (address signed/unsigned)
                        v4 -= v3
                    end
                else
                    v4 -= v3
                end
                v2 -= 1
                # TODO: worth allowing 0 rations?? - might be easier to skip that
                if v2 > 0 then
            again
        end

        i := num_meat
        save v4 - v5

        # TODO examine, debug, and test that this executes correctly!
        
        # TODO: Recovery - if there's a sick party member and food_safety permits, allow one member to recover. else...
        # TODO: Random events - if no recovery occurred, roll for a negative (or other positive?) event
        i := party_health
        load v2 - v2
        if v3 != v2 begin       # Is anyone alive but unhealthy?
            v0 := random 0xF   # TODO: work on odds... better rations = faster recovery
            if v0 <= v1 begin
                # Flash a quick message, then return
                #v8 := RECOVERY_MODE
                #i := curr_mode
                #save v8 - v8

                #reset_recovery_mode
 
                clear

                v0 := 0
                v1 := 8
                v2 := 64
                v3 := 16
                v4 := 8
                i := healed_img
                draw_img
                v0 := 3
                sp_delay

                i := party_health
                load v2 - v2
                v2 += 1
                save v2 - v2

                v8 := TRAVELING_MODE
                i := curr_mode
                save v8 - v8

                reset_traveling_mode

                return
            end
        end

        # TODO: Wear and tear - lose supplies or oxen? TODO: if 0 oxen or axels, should remain stationary??
        # TODO: (1) health up / down, (2) lose oxen, (3) lose wheels
        #       => Extract a random event calculator function!
        #       => Also consider a simple quicktime event minigame to prevent some hardships
        #
        i := travel_pace
        load v2 - v2
        #v1 := 0x01
        v1 <<= v2           # Increased pace results in increased odds of wear
        v0 := random 0xF    # TODO: work on odds... better rations = faster recovery
        if v0 <= v1 begin
            i := party_health
            load v2 - v2
            i := party_alive
            load v3 - v3
            i := party_dead
            load v4 - v4

            #v0 := random 0xF
            v0 := random 0x1
            #v0 := 0
            if v0 == 0 begin
                # if party_health is less than party_alive, kill one of the sick party
                # members.
                if v2 < v3 begin
                    i := party_alive
                    v3 -= 1
                    save v3 - v3

                    i := party_dead
                    v4 += 1
                    save v4 - v4

                    # Display the death image
                    clear
                    v0 := 8
                    v1 := 8
                    v2 := 48
                    v3 := 16
                    v4 := 8
                    i := died_small_img
                    draw_img

                    v0 := 3
                    sp_delay

                    # Check for party_alive == 0
                    if v3 == 0 begin
                        # switch mode - game over
                        v8 := GAME_OVER_MODE
                        i := curr_mode
                        save v8 - v8

                        # Game over condition
                        reset_game_over_mode
                        return
                    end

                    reset_traveling_mode
                    return
                end
            end

            i := party_health
            if v2 > 0 then v2 -= 1
            save v2 - v2

            # Flash a quick message, then return
            clear
            v0 := 0
            v1 := 0
            v2 := 64
            v3 := 32
            v4 := 8
            i := hardship_img
            draw_img
            v0 := 3
            sp_delay

            v8 := TRAVELING_MODE
            i := curr_mode
            save v8 - v8

            reset_traveling_mode

            return
        end
    end

    # Travel forward at the appropriate pace
    i := travel_pace
    load v5 - v5
    v8 += v5
    if v8 >= GAME_COUNTER_LOW_SIZE begin
        v9 += 1
        v8 -= GAME_COUNTER_LOW_SIZE

        i := game_counter
        save v8 - v9

        # TODO: initiate real river crossing minigame
        if v9 == 10 then v0 := 0xAA
        if v9 == 20 then v0 := 0xAA
        if v9 == 35 then v0 := 0xAA
        if v0 == 0xAA begin
            clear
            v0 := 8
            v1 := 8
            v2 := 48
            v3 := 16
            v4 := 8
            i := river_small_img
            draw_img
            v0 := 3
            sp_delay
            reset_traveling_mode
            return
        end
    end
    i := game_counter
    save v8 - v9

    if v9 == GAME_COUNTER_HIGH_SIZE begin
        # switch mode - game over
        v8 := GAME_OVER_MODE
        i := curr_mode
        save v8 - v8

        # Game over condition
        reset_game_over_mode
        return
    end
	
    # Draw
    draw_travel_animation

    #TODO: implement correct animation progress code.
    i := rolling_anim_index
    load v8 - v8
    v8 += 1
    if v8 >= 4 then v8 := 0
    save v8 - v8

    i := wheel_frames_xor_frame0
    if v8 > 0 begin
        v2 := 8
        loop
            i += v2
            v8 -= 1
            if v8 > 0 then
        again
    end
    v0 := 37
    v1 := 22
    sprite v0 v1 8
    v0 += 10
    sprite v0 v1 8

    :call sync
    return

: draw_stat
    # Draw inventory stats - dollars, meat, oxen, wheels, bullets
    #i := num_meat
    #load v6 - v7
    #v0 := 34
    #v1 := 16
    loop
        #v6 := 0xFF
        if v7 >= 8 then v6 := 0xFF
        if v7 == 7 then v6 := 0xFE
        if v7 == 6 then v6 := 0xFC
        if v7 == 5 then v6 := 0xF8
        if v7 == 4 then v6 := 0xF0
        if v7 == 3 then v6 := 0xE0
        if v7 == 2 then v6 := 0xC0
        if v7 == 1 then v6 := 0x80
        i := ui_dummy_var
        save v6 - v6
        sprite v0 v1 1

        v0 += 8

        if v7 <= 8 then v7 := 0
        if v7 > 8 then v7 -= 8
        if v7 > 0 then
    again
    return

##################################################
# River-crossing mode
##################################################

##################################################
# Random misfortune event mode
##################################################

##################################################
# Trading mode
##################################################

##################################################
# Options UI mode
# - Interactive mode to reconfigure game properties
# - Set rations, travel speed, and ???
# - Buy/Sell supplies
# - Initiate rest?
# - "work" for food/money/assistance
# - Other disturbing choices?? - RNG
##################################################
# Settings
# - Rations
# - Travel pace
# - Initiate rest
# - 

# Temporary variables used in UI mode
: ui_dummy_var
0
: cursor        # effectively map to a variable, upper/lower limits, and screen content
0
: last_cursor
0
: last_val      # value stored before last reset
0

# Setup/reset UI mode
#
: reset_ui_mode
    v8 := 0
    i := ui_dummy_var
    save v8 - v8

    # Clear and draw initial screen
    clear

	# Load current cursor position
	i := cursor
    load v8 - v8

    v0 := 10
    v1 := 4
    v2 := 48
    v3 := 8
    v4 := 8
	if v8 == GAME_SETTINGS_PACE then i := icon_pace
	if v8 == GAME_SETTINGS_RATIONS then i := icon_rations
	if v8 == GAME_SETTINGS_REST then i := icon_rest
    draw_img

    i := last_val
    load v7 - v7
    # Draw value
    i := settings_meter_large
    v0 := 16
    v1 := 18
    if v7 == 0 then i := settings_meter_small
    sprite v0 v1 3

    v0 := 24
    v1 := 18
    if v7 == 1 then i := settings_meter_small
    sprite v0 v1 3

    v0 := 32
    v1 := 18
    if v7 == 2 then i := settings_meter_small
    sprite v0 v1 3

    v0 := 40
    v1 := 18
    if v7 == 3 then i := settings_meter_small
    sprite v0 v1 3

    v0 := 48
    v1 := 18
    if v7 == 4 then i := settings_meter_small
    sprite v0 v1 3

    return

# UI mode loop
: loop_ui_mode
    # user input
    vf := 0
    ve := OCTO_KEY_W if ve key then vf := OCTO_KEY_W  # Perhaps provide "hot keys" for async events like hunting
    ve := OCTO_KEY_A if ve key then vf := OCTO_KEY_A
    ve := OCTO_KEY_S if ve key then vf := OCTO_KEY_S
    ve := OCTO_KEY_D if ve key then vf := OCTO_KEY_D
    ve := OCTO_KEY_E if ve key then vf := OCTO_KEY_E
    ve := OCTO_KEY_V if ve key then vf := OCTO_KEY_V
    ve := vf

	# Exit settings mode
    if ve == OCTO_KEY_V begin
        v8 := TRAVELING_MODE
        i := curr_mode
        save v8 - v8

        reset_traveling_mode
        return  # return and mode2 will execute
    end

	# Load current cursor position
	i := cursor
    load v8 - v8

    # Erase
    # (draw the "old" label/value, then point to the new label/value
    v0 := 10
    v1 := 4
    v2 := 48
    v3 := 8
    v4 := 8
	if v8 == GAME_SETTINGS_PACE then i := icon_pace
	if v8 == GAME_SETTINGS_RATIONS then i := icon_rations
	if v8 == GAME_SETTINGS_REST then i := icon_rest
    draw_img

    i := last_val
    load v7 - v7
    # Draw value
    i := settings_meter_large
    v0 := 16
    v1 := 18
    if v7 == 0 then i := settings_meter_small
    sprite v0 v1 3

    v0 := 24
    v1 := 18
    if v7 == 1 then i := settings_meter_small
    sprite v0 v1 3

    v0 := 32
    v1 := 18
    if v7 == 2 then i := settings_meter_small
    sprite v0 v1 3

    v0 := 40
    v1 := 18
    if v7 == 3 then i := settings_meter_small
    sprite v0 v1 3

    v0 := 48
    v1 := 18
    if v7 == 4 then i := settings_meter_small
    sprite v0 v1 3

    # Draw
    # -- load the value
    # -- load the label
    # -- display the 

    # Up/Down to choose between game settings (and maybe display fixed values?):
    i := cursor
    load v8 - v8
    if ve == OCTO_KEY_S begin
        v8 += 1
        if v8 == GAME_SETTINGS_NUM then v8 := 0
    end
    if ve == OCTO_KEY_W begin
        if v8 == 0 then v8 := GAME_SETTINGS_NUM
        v8 -= 1
    end
    save v8 - v8

    # Load the setting from v8
    if v8 == GAME_SETTINGS_PACE begin
        i := travel_pace
        load v7 - v7
        # load "PACE" logo
        # load pace high/low limits?
    end
    if v8 == GAME_SETTINGS_RATIONS begin
        i := rations
        load v7 - v7
        # load "RATIONS" logo
        # load rations high/low limits?
    end
    #if v8 == GAME_SETTINGS_REST begin
    #    # Execute resting from this UI?
    #end

    
    # Left/Right to increment decrement
    if ve == OCTO_KEY_A begin
        # increase the selected setting
        if v7 != 0 then v7 -= 1
    end
    if ve == OCTO_KEY_D begin
        # decrease the selected setting without wrapping
        v7 += 1
    end
    i := last_val
    save v7 - v7


    # Write the setting back
    if v8 == GAME_SETTINGS_PACE begin
        i := travel_pace
        save v7 - v7
        # load "PACE" logo
        # load pace high/low limits?
    end
    if v8 == GAME_SETTINGS_RATIONS begin
        i := rations
        save v7 - v7
        # load "RATIONS" logo
        # load rations high/low limits?
    end

	# Draw label
    v0 := 10
    v1 := 4
    v2 := 48
    v3 := 8
    v4 := 8
	if v8 == GAME_SETTINGS_PACE then i := icon_pace
	if v8 == GAME_SETTINGS_RATIONS then i := icon_rations
	if v8 == GAME_SETTINGS_REST then i := icon_rest
    draw_img

    # Draw value
    i := settings_meter_large
    v0 := 16
    v1 := 18
    if v7 == 0 then i := settings_meter_small
    sprite v0 v1 3

    v0 := 24
    v1 := 18
    if v7 == 1 then i := settings_meter_small
    sprite v0 v1 3

    v0 := 32
    v1 := 18
    if v7 == 2 then i := settings_meter_small
    sprite v0 v1 3

    v0 := 40
    v1 := 18
    if v7 == 3 then i := settings_meter_small
    sprite v0 v1 3

    v0 := 48
    v1 := 18
    if v7 == 4 then i := settings_meter_small
    sprite v0 v1 3

    sync
    return

##################################################
# Hunting mode
##################################################
# - TODO: attempt an interactive mode, like hunting
# - TODO: implement ending scenario that returns back to the main mode

# Temporary variables used in hunting mode
#
: hunter_x
0
: hunter_y
0
: aim_angle
0
: target_x
0
: target_y
0
: bullet
: bullet_x 0
: bullet_y 0
: bullet_vx 0
: bullet_vy 0

: bullet_vx_counter
: bullet_vx_counter_limit 0
: bullet_vx_counter_val 0

: animal_1
: animal_1_x 0
: animal_1_y 0
: animal_1_vx 0
: animal_1_vy 0
: animal_1_type 0 # 0 = disabled, 1 = slow deer, 2 = faster deer with pauses, 3 = fast rabbit, 4 = standing bison


# Setup/reset hunting mode
#
: reset_hunting_mode
    v8 := 32
    i := hunter_x
    save v8 - v8
    v8 := 16
    i := hunter_y
    save v8 - v8
    v8 := 0
    i := aim_angle
    save v8 - v8
    i := target_x
    save v8 - v8
    i := target_y
    save v8 - v8
    i := bullet_x
    save v8 - v8
#    v9 := -1
    i := bullet_y
#    save v9 - v9
    save v8 - v8
    i := bullet_vx
    save v8 - v8
    i := bullet_vy
    save v8 - v8
    i := animal_1_type
    save v8 - v8

    # Alternative:
    #v0 := 0     # hunter_x
    #v1 := 0     # hunter_y
    #v2 := 0     # aim_angle
    #v3 := 0     # target_x
    #v4 := 0     # target_y
    #v5 := 0     # bullet_x
    #v6 := 0     # bullet_y
    #i := hunter_x
    #save v0 - v6

    clear

    v0 := 8
    v1 := 8
    v2 := 48
    v3 := 16
    v4 := 8
    i := hunt_small_img
    draw_img

    # HACK: sleep for 3 seconds
    #v0 := 5
    #v1 := 60
    #delay := v1
    #loop
    #    v1 := delay
    #    if v1 == 0 begin
    #        v0 -= 1
    #        if v0 != 0 begin
    #            v1 := 60
    #            delay := v1
    #        end
    #    end
    #    if v1 != 0 then 
    #again

    v0 := 1
    sp_delay

    clear

    # Draw the cursor
    i := hunter_x
    load v6 - v7
    i := crosshair_img
    sprite v6 v7 3

    return

# Hunting mode loop - animate a simple shooting gallery
: loop_hunting_mode
    # user input
    vf := 0
    ve := OCTO_KEY_W if ve key then vf := OCTO_KEY_W  # Perhaps provide "hot keys" for async events like hunting
    ve := OCTO_KEY_A if ve key then vf := OCTO_KEY_A
    ve := OCTO_KEY_S if ve key then vf := OCTO_KEY_S
    ve := OCTO_KEY_D if ve key then vf := OCTO_KEY_D
    ve := OCTO_KEY_E if ve key then vf := OCTO_KEY_E
    ve := OCTO_KEY_V if ve key then vf := OCTO_KEY_V
    ve := vf

#    :monitor hunter_x 2
#    :monitor ve 1

    # Erase cursor
    i := hunter_x
    load va - vb
    i := crosshair_img
    sprite va vb 3

    i := hunter_x
    load va - vb
    if ve == OCTO_KEY_A then va -= 1
    if ve == OCTO_KEY_D then va += 1
    if ve == OCTO_KEY_W then vb -= 1
    if ve == OCTO_KEY_S then vb += 1
    save va - vb

#    # Draw the cursor
#    i := crosshair_img
#    sprite va vb 3

#    if ve == OCTO_KEY_V begin
#        # Reset bullet location and compute velocities
#        v8 := 32
#        v9 := 32
#        i := bullet_x
#        save v8 - v9
#    end
    if ve == OCTO_KEY_V begin
        v8 := TRAVELING_MODE
        i := curr_mode
        save v8 - v8

        reset_traveling_mode
        return  # return and mode2 will execute
    end

    i := bullet
    load v3 - v6
    if ve == OCTO_KEY_E begin
        i := num_bullets        # num_bullets must be positive
        load vd - vd
        if v4 != 0 then vd := 0 # if there's a bullet in flight, do not allow a new bullet
        #if v4 == 0 begin
        if vd > 0 begin
            # Decrement available bullets
            vd -= 1
            i := num_bullets
            save vd - vd

            # Init a bullet
            v3 := 32    # bullet_x
            v4 := 31    # bullet_y
            #v5 := random 0x03    # bullet_vx
            #v5 -= 0x01
            v5 := -1
            if va > 32 then v5 := 1
            if va == 32 then v5 := 0
            v6 := -1    # bullet_vy

            # compute a fractional vx value for moving toward the cursor...but convert it
            # to a "sub counter" that is not fractional. i.e., have an increments until
            v1 := 32
            v1 -= va    # v1: dist_x between bullet and target
            v2 := 32
            v2 -= vb    # v2: dist_y between bullet and target

            # Add two bits of fraction to the division result
            vd <<= v2   # *= 2
            v2 <<= vd   # *= 2

            v0 := 0     # v0: compute the number of times dist_x can be added to sum to dist_y, an approximation of dist_y/dist_x
            if va < 32 begin   # TODO: these three blocks should be cleaned up!
                loop
                    v0 += 1
                    v2 -= v1
                    if v2 > v1 then
                again
            end
            if va > 32 begin
                loop
                    v0 += 1
                    v2 += v1
                    if v2 < v1 then     # Once v2 goes negative, it will be >= v1
                again
            end
            if va == 32 begin
                v0 := 0
                v5 := 0
            end
            # For example, if dist_x = 2 and dist_y = 14, v0 is now 7. Each step in the y direction, add to a counter, taking a step in the x direction when it reaches 7
            v1 := 0
            i := bullet_vx_counter
            save v0 - v1
            
            i := bullet
            save v3 - v6

            i := bullet_img
            sprite v3 v4 1
        end
    end
    i := bullet
    save v3 - v6

    # Spawn new animal(s)
    i := animal_1
    load v0 - v4
    if v4 == 0 begin
        # No animal, so try rolling for a new one
        v5 := random 0x1F
        if v5 == 0 begin
            v4 := random 0x03
            v4 += 1
            v0 := 56
            v1 := 10
            v2 := -1
            v3 := 0

            i := animal_type_1_img
            sprite v0 v1 6
        end
    end

    # Move animal(s)
    if v4 != 0 begin
        i := animal_type_1_img
        sprite v0 v1 6
    
        v0 += v2
        v1 += v3

        if v0 > 0 begin
            i := animal_type_1_img
            sprite v0 v1 6
        else
            v4 := 0
        end
    end
    i := animal_1
    save v0 - v4

    # Bullet erase, move, redraw, check collision
    i := bullet
    load v3 - v6
    if v4 > 0 begin
        i := bullet_img
        sprite v3 v4 1

        # If the bullet is moving horizontally, use the vx counter
        if v5 != 0 begin
            i := bullet_vx_counter
            load v0 - v1
            v1 += 4     # Equivalent to fixed-point: 1 << 2
            if v1 >= v0 begin
                loop
                    v3 += v5
                    v1 -= v0
                    if v1 >= v0 then
                again
            end
            save v0 - v1
        end

        v4 += v6
        i := bullet
        save v3 - v6

        # Check collisions
        if v3 >= 64 begin
            # bullet moved off screen
            v4 := 0
            i := bullet
            save v3 - v6
        else
            if v4 > 0 begin
                i := bullet_img
                vf := 0
                sprite v3 v4 1
                if vf != 0 begin
                    # Erase the bullet
                    i := bullet_img
                    sprite v3 v4 1
                    v4 := 0
                    i := bullet
                    save v3 - v6

                    # TODO: handle different animal types
                    i := animal_1
                    load v0 - v4
#                    :monitor animal_1_x  1
#                    :monitor animal_1_y  1
#                    :monitor animal_1_vx 1
#                    :monitor animal_1_vy 1
                    i := animal_type_1_img
                    sprite v0 v1 6      # Erase
                    v4 := 0             # Disable
                    i := animal_1
                    save v0 - v4

                    i := num_meat
                    load vc - vd
                    vf := 32           # TODO: random, based on animal size. Maybe add a zero?
                    vc += vf
                    vd += vf # carry
                    save vc - vd
                end
            end
        end
    end


    # Draw the cursor
    i := hunter_x
    load va - vb
    i := crosshair_img
    sprite va vb 3

    # logic
    # - roll the dice for random events

    # animate cart
    # - make the cart shake
    #v0 := 32
    #v1 := 0
    #v2 := 32
    #v3 := 32
    #i := cart
    #:call draw_img
		
    #v0 := 0
    #v1 := 0
    #v2 := 64
    #v3 := 32
    #v4 := 8
    #i := sign_river
    #:call draw_img


    sync
    return

# Mode #3 -----------------------------------------
# - TODO: animated sequence based on sequence of frame

# Temporary variables used in mode #3
#

# Setup/reset mode #3
#
#: reset_hardship_mode
#
#    # TODO: support a specific splash screen timer or a generic animation timer
#
#    # Draw initial splash screen
#    clear
#
#    v0 := 0
#    v1 := 0
#    v2 := 64
#    v3 := 32
#    v4 := 8
#    i := hardship
#    draw_img
#
#    v0 := 1
#    sp_delay
#
#    #########################################################
#
#    clear
#
#    return

# Loop mode #3 - accumulate gold, using some of resource #1 and #2
# - this mode will potentially spend away resources
# - gold will be spendable to change how resources are obtained
#: loop_hardship_mode
#
#    # user input
#    vf := 0
#    ve := OCTO_KEY_W if ve key then vf := OCTO_KEY_W  # Perhaps provide "hot keys" for async events like hunting
#    ve := OCTO_KEY_A if ve key then vf := OCTO_KEY_A
#    ve := OCTO_KEY_S if ve key then vf := OCTO_KEY_S
#    ve := OCTO_KEY_D if ve key then vf := OCTO_KEY_D
#
#    if vf == OCTO_KEY_W begin
#        v8 := TRAVELING_MODE
#        i := curr_mode
#        save v8 - v8
#
#        :call reset_traveling_mode
#        return
#    end
#
#    return

##################################################
# Game over and retry mode
##################################################

# Temporary variables used in game over mode
#

# Setup/reset game over mode
#
: reset_game_over_mode

    # TODO: support a specific splash screen timer or a generic animation timer

    # Draw initial splash screen
    clear

    v0 := 0
    v1 := 0
    v2 := 64
    v3 := 32
    v4 := 8
    i := game_over_img
    draw_img

    v0 := 1
    sp_delay

    #clear
    return

# Loop mode #4 - Simply display a summary and allow retry
: loop_game_over_mode

    # user input
    vf := 0
    #ve := OCTO_KEY_W if ve key then vf := OCTO_KEY_W  # Perhaps provide "hot keys" for async events like hunting
    ve := OCTO_KEY_A if ve key then vf := OCTO_KEY_A
    #ve := OCTO_KEY_S if ve key then vf := OCTO_KEY_S
    #ve := OCTO_KEY_D if ve key then vf := OCTO_KEY_D

    if vf == OCTO_KEY_A begin
        # switch mode - Reset back to mode 0
        v8 := TITLE_MODE
        i := curr_mode
        save v8 - v8

        reset_game
        reset_title_mode

        return
    end

    return

#--------------------------------------------------
# Image data

#--------------------------------------------------

: cart # (128 bytes)
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0x1F 0xF8 0xFF 0xFF 0xCF 0x03 0x00 0xFE
	0xEF 0xF3 0xFB 0xFC 0xEF 0xE7 0xF3 0xFD
	0xEF 0xEF 0xF7 0xFD 0xEF 0xEF 0xF7 0xFB
	0xEF 0xEF 0xE7 0xFB 0x0F 0xE4 0x03 0xF8
	0xFF 0x03 0xFC 0xFD 0x07 0xE4 0x02 0xFC
	0xF3 0x69 0x85 0xFD 0x1D 0x97 0x4A 0xFA
	0xB5 0x68 0x35 0xF8 0xC5 0x08 0x49 0xFA
	0x25 0x69 0xAB 0xF8 0x1D 0x72 0x52 0xFD
	0xFB 0xF8 0x8C 0xFE 0x07 0xFE 0x01 0xFE

# Semi-general drawing function
: draw_cart
	va := 24  # x
	vb := 0   # y
	vc := 1   # stride
	i := cart
	loop
		sprite va vb 1
		i  += vc
		va += -8
		if va == -8 then vb +=  1
		if va == -8 then va := 24
		if vb != 32 then
    again
	
    return


# Draw Left-to-right, top-to-bottom
# java -cp ~/stuff/Octo/tools/ImagePack ImagePack cart.png --sprite=8 --order=tblr > cart_tblr.txt
: cart_tblr # (128 bytes)
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFE
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x00
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xF8 0x03
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x1F 0xCF
#	0xFC 0xFD 0xFD 0xFB 0xFB 0xF8 0xFD 0xFC
#	0xFB 0xF3 0xF7 0xF7 0xE7 0x03 0xFC 0x02
#	0xF3 0xE7 0xEF 0xEF 0xEF 0xE4 0x03 0xE4
#	0xEF 0xEF 0xEF 0xEF 0xEF 0x0F 0xFF 0x07
#	0xFD 0xFA 0xF8 0xFA 0xF8 0xFD 0xFE 0xFE
#	0x85 0x4A 0x35 0x49 0xAB 0x52 0x8C 0x01
#	0x69 0x97 0x68 0x08 0x69 0x72 0xF8 0xFE
#	0xF3 0x1D 0xB5 0xC5 0x25 0x1D 0xFB 0x07

: cart2
	0x10 0xEE 0xC6 0x6C 0x7C 0xC6

: img_person_healthy
    0xE0 0xE0 0x40 0x40
: img_person_sick
    0x00 0x40 0xE0 0x40
: img_person_dead
    0x40 0xE0 0x40 0xE0

: crosshair_img
    0x40 0xA0 0x40
: bullet_img
    0x80
: animal_type_1_img
    0x20 0x60 0xEE 0x3F 0x33 0x21

# Draw Left-to-right, top-to-bottom
# java -cp ~/stuff/Octo/tools/ImagePack ImagePack title.png --sprite=8 --order=tblr > title.txt
: title_img # (256 bytes)
	0xFF 0xFE 0xF8 0xE3 0xC7 0xCF 0x8F 0x9F
	0xFF 0x1F 0x0F 0xC7 0xC7 0xC7 0xC7 0xC6
	0xFF 0xFF 0xFF 0xFF 0xFE 0x9E 0x0C 0x40
	0xFF 0xFF 0xFF 0x3F 0x7F 0x7F 0x7C 0x19
	0xFF 0xFF 0xFF 0xFF 0xFF 0x1F 0x1E 0x8C
	0xFF 0xFF 0xFF 0xFF 0xFF 0x87 0x06 0xCC
	0xFF 0xFF 0xFF 0xFF 0xFF 0x8F 0x0C 0xC0
	0xFF 0xFF 0xFF 0xFF 0xFF 0x73 0x03 0x03
	0x9F 0x9F 0x9F 0x9F 0x8F 0x80 0xE1 0xFF
	0xC4 0xCC 0xC8 0x98 0x38 0x78 0xFC 0xFF
	0xFC 0xFC 0xFC 0xE8 0xC8 0x18 0x7C 0xFF
	0xF1 0xF3 0xE3 0xC3 0x03 0x60 0xF1 0xFF
	0x89 0x99 0x99 0x11 0x30 0x71 0xF3 0xE7
	0xC8 0x89 0x91 0x11 0x11 0x10 0x18 0x3F
	0xC6 0xCE 0xCC 0x8C 0x9C 0x3C 0xF9 0xFF
	0x27 0x67 0x67 0xC7 0xC1 0xC3 0xCF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xF0 0xC0 0x9E 0x3E 0x3C 0x3C 0x1C
	0xFB 0x03 0x03 0x7F 0x7F 0x79 0x60 0xC0
	0xCF 0x9E 0x80 0x81 0xFF 0x30 0x20 0x0C
	0x3F 0x33 0xF1 0xF3 0xFF 0x77 0x47 0x87
	0xF3 0xC3 0x9F 0x9F 0x1F 0x3F 0x3F 0x3F
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0x3C 0xFC 0xF8 0xF9 0xFB 0xE0 0xC0 0xFF
	0xF3 0xF3 0xE3 0xE7 0xE7 0x27 0xCF 0xFF
	0x9C 0x98 0x98 0x19 0x00 0x00 0x99 0xFF
	0xE6 0xC6 0xCE 0x0C 0x00 0x84 0xCC 0xFE
	0x3F 0x7F 0x7F 0x7F 0x4F 0x1F 0x7F 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	
# Draw Left-to-right, top-to-bottom
# java -cp ~/stuff/Octo/tools/ImagePack ImagePack sign_river.png --sprite=8 --order=tblr > sign_river.txt
: sign_river # (256 bytes)
#	0xFF 0xFF 0xC0 0x80 0xE0 0xE1 0xE1 0xE1
#	0xFF 0xFF 0x03 0x00 0xE0 0xF0 0xF0 0xF0
#	0xFC 0xF8 0xF8 0xF8 0xFD 0x7F 0x78 0xE0
#	0x7F 0x7F 0x7F 0x7F 0xFF 0xFF 0xFC 0xE0
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x73 0x61
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFC 0xE0
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x1F 0x0C
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x98 0x00
#	0xE1 0xC0 0xC0 0xC3 0xC3 0xC3 0x83 0x83
#	0xE0 0x01 0x07 0x07 0x87 0x83 0x83 0xC1
#	0xC0 0xF0 0xF0 0xF0 0xF1 0xE1 0xE1 0xE1
#	0xE0 0xF0 0xF0 0xF0 0xF0 0xF0 0xF1 0xE0
#	0xE1 0xE1 0xF1 0xF1 0xF1 0xF3 0xE3 0xC7
#	0xC3 0x87 0x87 0x04 0x00 0x0F 0x0F 0x0F
#	0x80 0x86 0x0E 0x1E 0x3E 0xFC 0xFC 0x8C
#	0x00 0x0C 0x1F 0x1F 0x1F 0x3F 0x3F 0x3F
#	0x83 0x01 0x01 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xC0 0xE0 0xE0 0xFF 0xFF 0xF0 0xF8 0xFC
#	0xE0 0x60 0xF0 0xFF 0xFF 0xCF 0xCF 0xBF
#	0x20 0x30 0xF8 0xFF 0xFF 0xE1 0xF3 0xF3
#	0x0F 0x1F 0x7F 0xFF 0xFF 0x3C 0x9C 0x8E
#	0x06 0x80 0xE0 0xFF 0xFF 0x78 0xE7 0xCF
#	0x1C 0x3C 0xFC 0xFF 0xFF 0xFF 0x3F 0xBF
#	0x3F 0x3F 0x7F 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFE 0xFE 0xFE 0xFC 0xFD 0xF1 0xFF 0xFF
#	0x3F 0x7F 0x3C 0x9F 0xCF 0x87 0xFF 0xFF
#	0xF3 0xF3 0x33 0xF3 0xF3 0xE1 0xFF 0xFF
#	0xA6 0xB2 0xB8 0xB8 0xBC 0x1E 0xFF 0xFF
#	0xCF 0xCF 0xCE 0xCF 0xE7 0xF0 0xFF 0xFF
#	0xBF 0xFF 0x1F 0x3F 0x3F 0x3F 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF

#: river_crossing_small # (192 bytes)
#	0x00 0x00 0x00 0x00 0x01 0x01 0x01 0x00
#	0x00 0x0E 0x7F 0xD9 0x99 0x9F 0xBC 0x3C
#	0x00 0x18 0x98 0x80 0x90 0x77 0x77 0x35
#	0x00 0x00 0x00 0x00 0x58 0xD9 0x9B 0x37
#	0x00 0x00 0x00 0x00 0xC5 0xDF 0xDE 0x8C
#	0x00 0x00 0x00 0x00 0x80 0x80 0x80 0x00
#	0x00 0x00 0x00 0x03 0x00 0x00 0x00 0x00
#	0x3E 0x66 0xE6 0xE7 0x03 0x01 0x00 0x00
#	0x33 0x6F 0x7B 0x63 0x10 0xF0 0x40 0x00
#	0x37 0x66 0xC7 0x87 0x00 0x00 0x00 0x00
#	0x0C 0x78 0xD8 0x18 0x00 0x00 0x00 0x00
#	0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
#	0x07 0x1F 0x31 0x61 0xC0 0xC0 0x80 0x80
#	0x00 0x80 0x80 0x2C 0xFD 0xF7 0x66 0x66
#	0x00 0x00 0x00 0x61 0xF3 0x36 0x37 0x63
#	0x00 0x00 0x00 0x8C 0x9D 0x31 0x38 0x18
#	0x60 0x60 0x00 0x44 0xDF 0xDF 0xCC 0xCD
#	0x00 0x00 0x00 0x41 0xC7 0xCC 0x99 0x99
#	0x80 0x82 0xFC 0xF0 0x00 0x00 0x00 0x00
#	0xC6 0xC7 0xC3 0x00 0x00 0x00 0x00 0x00
#	0x69 0xDF 0x0C 0x00 0x00 0x00 0x00 0x00
#	0xC9 0xF9 0x61 0x00 0x00 0x00 0x00 0x00
#	0xB9 0xF9 0x99 0x00 0x00 0x00 0x00 0x00
#	0xBF 0xFF 0x9B 0x23 0x42 0xFE 0x78 0x00

: river_small_img # (96 bytes)
	0x00 0x00 0x01 0x01 0x03 0x03 0x03 0x00
	0x1F 0x7F 0xD9 0x99 0x99 0xBF 0xBC 0x3C
	0x02 0x86 0xC6 0xC0 0x84 0x1C 0x3D 0x1D
	0x00 0x00 0x00 0x01 0x7B 0xFB 0xB3 0x63
	0x00 0x00 0x00 0x00 0x0C 0x3C 0x6D 0x7C
	0x00 0x00 0x00 0x00 0x2C 0xFC 0xFC 0x60
	0x00 0x00 0x00 0x03 0x07 0x00 0x00 0x00
	0x3E 0x66 0x66 0xF7 0xE3 0x03 0x01 0x00
	0x18 0x18 0x1E 0x3C 0x18 0x88 0xFC 0xF0
	0x66 0xC4 0xCC 0xF8 0x60 0x00 0x00 0x00
	0xF0 0xE2 0xC6 0xF9 0x71 0x00 0x00 0x00
	0xC0 0xC0 0xC0 0xC0 0x80 0x00 0x00 0x00

# Draw Left-to-right, top-to-bottom
# java -cp ~/stuff/Octo/tools/ImagePack ImagePack <>.png --sprite=8 --order=tblr > <>.txt
: hardship_img # (256 bytes)
	0xFF 0xFF 0xFF 0xE0 0xE0 0xF1 0xF1 0xE3
	0xFF 0xFF 0xFF 0x40 0xC1 0xE3 0xE3 0xE3
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xE0 0x80
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x38 0x30
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x8E 0x08
	0xFF 0xFF 0xFB 0xC3 0xC3 0xE3 0x07 0x07
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xE0 0xE0 0xE3 0xE3 0xE3 0xC3 0x81 0xFF
	0x03 0x07 0xC7 0xC7 0xC7 0x87 0x03 0xFF
	0x8E 0x1E 0x1C 0x1C 0x18 0x00 0x86 0xFF
	0x78 0x78 0x78 0x79 0x71 0x11 0x31 0xFF
	0x41 0xF1 0xE3 0xE3 0xF3 0xF0 0xF8 0xFF
	0xC7 0xC7 0xC7 0x87 0x87 0x03 0xC7 0xFF
	0xFF 0x1F 0x1F 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xE0 0xC4 0x8F 0x83
	0xFD 0xE1 0xE1 0xF3 0xE2 0x60 0x63 0xE3
	0xFF 0xFF 0xFF 0xFF 0x1E 0x1C 0x9E 0x9E
	0x1F 0x1F 0x3F 0xFF 0x3C 0x38 0x3C 0x3C
	0xFF 0xFF 0xFF 0xFF 0x43 0x01 0x31 0x71
	0xFF 0xCF 0x87 0x8F 0x8F 0x8F 0x9F 0x9F
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xC0 0xF0 0x38 0x00 0x81 0xFF 0xFF 0xFF
	0xE7 0x67 0x47 0xC7 0xC7 0xFF 0xFF 0xFF
	0x1E 0x1E 0x1C 0x04 0x8E 0xFF 0xFF 0xFF
	0x7C 0x7C 0x78 0x18 0x38 0xF8 0xF8 0xE0
	0x71 0xF1 0xE3 0x07 0x0F 0xFF 0xFF 0x7F
	0x9F 0xFF 0x3F 0x1F 0x3F 0xFF 0xFF 0xFF
	

# Draw Left-to-right, top-to-bottom
# java -cp ~/stuff/Octo/tools/ImagePack ImagePack game_over.png --sprite=8 --order=tblr > game_over.txt
: game_over_img # (256 bytes)
	0xFE 0xF8 0xE3 0xC7 0xCF 0x9F 0x9F 0x1C
	0x1F 0x0F 0x8F 0xCF 0xDF 0xFE 0xFC 0x09
	0xFF 0xFF 0xFF 0xFF 0x07 0x04 0xC8 0xCE
	0xFF 0xFF 0xFF 0xFF 0x73 0x02 0x00 0x22
	0xFF 0xFF 0xFF 0xFF 0x3C 0x38 0x32 0x64
	0xFF 0xFF 0xFF 0xFF 0xFF 0x7F 0x7F 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0x18 0x1F 0x1F 0x1E 0x00 0x82 0xFE 0xFC
	0x19 0x39 0x31 0x30 0x30 0x79 0x7F 0xFF
	0x8E 0x8C 0x90 0x00 0x0C 0x99 0xFF 0xFF
	0x66 0x46 0xCC 0xCC 0xCC 0x9C 0xFF 0xFF
	0x61 0x43 0x47 0x06 0x00 0xE3 0xFF 0xFF
	0xFF 0xFF 0x7F 0x7F 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFC 0x81 0x87 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFC 0xF0 0xC7 0x8F 0x9F 0x1F 0x3F 0x3F
	0x3F 0x1F 0x8F 0x8F 0x8F 0x88 0x88 0x82
	0xFF 0xFF 0xFF 0xFF 0xE3 0x23 0x32 0x60
	0xFF 0xFF 0xFF 0xFF 0x9E 0x08 0x40 0x9C
	0xFF 0xFF 0xFF 0xFF 0x4F 0x0F 0x1F 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0x3F 0x3F 0x3F 0x1E 0x00 0xC3 0xFF 0xFF
	0x90 0x9C 0x38 0x78 0xF8 0xFC 0xFF 0xFF
	0xE4 0xE0 0xC8 0x98 0x38 0x7C 0xFF 0xFF
	0x3C 0x78 0xE9 0xC9 0x19 0x73 0xFF 0xFF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF

: healed_img # (256 bytes)
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xFF 0xFF 0xC0 0xC1 0xE3 0xE3 0xE3 0xE0
	0xFF 0xFF 0x81 0x81 0xE3 0xE3 0xE3 0x03
	0xFF 0xFF 0xFF 0xFF 0xFF 0xC1 0x80 0x18
	0xFF 0xFF 0xFF 0xFF 0xFF 0xF0 0xC0 0xC6
	0xFF 0xFD 0xF0 0xF0 0xF8 0xF8 0x78 0x38
	0xFF 0xFF 0xFF 0xFF 0xFF 0xF0 0xE0 0xC6
	0xFF 0xFF 0xFF 0xFF 0xFF 0x7C 0x38 0x31
	0xFF 0xE7 0x87 0x87 0xC7 0x07 0x07 0xC7
	0xE0 0xE3 0xE3 0xE3 0xC1 0xC0 0xFF 0xFF
	0x03 0xE3 0xE3 0xE3 0xC3 0x81 0xFF 0xFF
	0x00 0x1F 0x1F 0x0E 0x80 0xC1 0xFF 0xFF
	0x6C 0xE0 0xC6 0x46 0xC0 0xE1 0xFF 0xFF
	0x38 0x38 0x38 0x38 0x10 0x00 0xFF 0xFF
	0xC0 0xC7 0xC7 0xC3 0xE0 0x70 0xFF 0xFF
	0x11 0xF1 0xF1 0x91 0x38 0x7C 0xFF 0xFF
	0xC7 0xC7 0xC7 0xC7 0x03 0x03 0xFF 0xFF

#: hunt_img # (256 bytes)
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFE
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x80 0x00
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFE 0x7C 0xF8
#	0xFF 0xFF 0xFF 0x87 0x07 0x0F 0x7F 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFC 0xF8 0xF8 0xF8 0xF0 0xF0 0xF9 0xFF
#	0x21 0xE1 0xE1 0xE3 0xE3 0xC3 0xC0 0x80
#	0xF8 0xF0 0xF1 0xF1 0xE1 0xE1 0x03 0x03
#	0xFF 0xFF 0xFF 0xFF 0xF3 0xC3 0x03 0x03
#	0xFF 0xFF 0xFF 0xFF 0xE7 0x87 0x8C 0x8C
#	0xFF 0xFF 0xFF 0xFF 0xCF 0x0C 0x00 0x00
#	0xFF 0xFF 0xFF 0xFF 0x1F 0x18 0x30 0x3E
#	0xCF 0x0F 0x1F 0x1F 0x1F 0x01 0x03 0x3F
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFE 0xC0 0xC0
#	0x87 0x87 0x8F 0x8F 0x1F 0x3F 0x7F 0xFF
#	0xC3 0xC3 0xC7 0xC7 0x87 0x87 0x80 0x80
#	0xC7 0xC7 0xC7 0x87 0x8E 0x80 0x00 0x86
#	0x0F 0x1F 0x1F 0x1F 0x12 0x02 0x06 0x1C
#	0x06 0x1C 0x1C 0x1C 0x1C 0x38 0x38 0x38
#	0x3E 0x3C 0x7C 0x7C 0x64 0x0C 0x1C 0x3C
#	0x3F 0x3F 0x7F 0x7B 0x63 0x07 0x0F 0x3F
#	0x83 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0x8F 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0x8E 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0x7C 0xFD 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0x78 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0xFC 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
#	0x7F 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF

: hunt_small_img # (96 bytes)
	0x00 0x00 0x00 0x03 0x07 0x06 0x0E 0x0E
	0x00 0x00 0xF8 0xF8 0x30 0x70 0x70 0x61
	0x0E 0x3C 0x70 0x60 0xE0 0xC0 0xC6 0xDE
	0x00 0x00 0x00 0x00 0x00 0x00 0x31 0x77
	0x00 0x00 0x00 0x00 0x00 0x00 0x88 0xBD
	0x00 0x00 0x00 0x10 0x30 0x70 0x60 0xFC
	0x04 0x00 0x00 0x00 0x01 0x03 0x1E 0x3C
	0xFF 0xFB 0xE3 0xC3 0x83 0x83 0x07 0x07
	0xFE 0x8C 0x8C 0x9C 0x9D 0x1F 0xFF 0x98
	0x6F 0x63 0xE3 0xC3 0xCF 0xFE 0xE6 0xCE
	0xFB 0xD8 0x38 0x38 0x33 0x3F 0x7D 0x30
	0xF8 0xE0 0xE0 0xC0 0xC8 0xF8 0xF0 0xC0

: died_small_img # (96 bytes)
	0x00 0x00 0x7F 0x18 0x18 0x18 0x18 0x18
	0x00 0x00 0xC3 0x60 0x30 0x30 0x18 0x18
	0x00 0x00 0xF7 0xC1 0xC1 0xC1 0xC1 0xC1
	0x00 0x00 0xFE 0x86 0x82 0x82 0x90 0xB0
	0x00 0x00 0x3F 0x0C 0x0C 0x0C 0x0C 0x0C
	0x00 0x00 0xE0 0x30 0x18 0x18 0x0C 0x0C
	0x18 0x18 0x18 0x18 0x18 0x18 0x7F 0x00
	0x18 0x18 0x18 0x30 0x30 0x60 0xC3 0x00
	0xC1 0xC1 0xC1 0xC1 0xC1 0xC1 0xF7 0x00
	0xF0 0x90 0x91 0x81 0x83 0x83 0xFF 0x00
	0x0C 0x0C 0x0C 0x0C 0x0C 0x0C 0x3F 0x00
	0x0C 0x0C 0x0C 0x18 0x18 0x30 0xE0 0x00

: settings_meter_large
0xE0 0xA0 0xE0

: settings_meter_small
0x00 0x40 0x00

: small_cart
0x02 0x05 0x04 0x04 0x04 0x04 0x02 0x03 0x00 0x00 0x00 0xF8 0x00 0x00 0x00
0x22 0xDD 0x00 0x22 0x22 0x22 0x00 0xFF 0x00 0x00 0x00 0x00 0x00 0x06 0x00
0x22 0xDD 0x01 0x21 0x21 0x21 0x02 0xFE 0x02 0x00 0x00 0x00 0x00 0x00 0x00

: wheel_frames_xor
0x3C 0x7E 0xFF 0xCF 0xF3 0xFF 0x7E 0x3C
: wheel_frames_xor_frame0
0x00 0x00 0x20 0x20 0x04 0x04 0x00 0x00
0x00 0x00 0x04 0x38 0x1C 0x20 0x00 0x00
0x00 0x00 0x0C 0x00 0x00 0x30 0x00 0x00
0x00 0x00 0x28 0x18 0x18 0x14 0x00 0x00

#: icon_pace
#0x00 0x00 0x00 0x00 0x4C 0x66 0x33 0x19 0x32 0x66 0x4C 0x00 0x00 0x00 0x00

#: icon_rations
#0x20 0x10 0x08 0x04 0x62 0x5A 0x42 0x42 0x62 0x3C 0x00 0x00 0x00 0x00 0x00

# icon_rest
#0x00 0x00 0xE0 0x20 0x40 0x8E 0xE2 0x04 0x08 0x0E 0x00 0x00 0x00 0x00 0x00

: text_pace # (32 bytes)
: icon_pace
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xE0 0xEE 0xEE 0xEE 0xE1 0xEF 0xEF 0xEF
	0xE7 0xE7 0xD3 0xDB 0xDB 0x81 0xBD 0xBD
	0xC2 0xBE 0x7E 0x7E 0x7E 0x7E 0xBE 0xC2
	0x0F 0xFF 0xFF 0x0F 0xFF 0xFF 0xFF 0x0F
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF

: text_rations # (48 bytes)
: icon_rations
	0xC1 0xDD 0xDD 0xDD 0xC1 0xDD 0xDE 0xDE
	0xE4 0xE7 0xD3 0xDB 0xDB 0x81 0xBD 0x3D
	0x05 0xBD 0xBD 0xBD 0xBD 0xBD 0xBD 0xBD
	0xE3 0xDD 0xBE 0xBE 0xBE 0xBE 0xDD 0xE3
	0x9D 0x8D 0xAD 0xB5 0xB5 0xB9 0xB9 0xBD
	0xC3 0xBF 0xBF 0xCF 0xF3 0xFB 0xFB 0x83

: text_rest # (32 bytes)
: icon_rest
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
	0xC1 0xDD 0xDD 0xDD 0xC1 0xDD 0xDE 0xDE
	0x83 0xBF 0xBF 0x83 0xBF 0xBF 0xBF 0x83
	0x84 0x7F 0x7F 0x9F 0xE7 0xF7 0xF7 0x07
	0x07 0xBF 0xBF 0xBF 0xBF 0xBF 0xBF 0xBF
	0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF

# Try writing a general drawing function
: draw_img
    # v0 = x
    # v1 = y
    # v2 = w, multiple of 8
    # v3 = h, multiple of 8
    # v4 = stride (8 for 8x8 tile)
    # i = image
    v5 := v0
    v5 += v2    # v5 = x + w    <== note: could just repurpose v2
    v6 := v1
    v6 += v3    # v6 = y+h      <== note: could just repurpose v3
    va := v0    # xi
    vb := v1    # yi
    loop
        sprite va vb 8
        i += v4
        va += 8
        if va == v5 then vb += 8                # TODO: use higher vertical sprites
        if va == v5 then va := v0
        if vb != v6 then
    again
    return
