/** @file Main.c
 * Entry point and main loop for the Chip-8 Console.
 * @author Adrien RICCIARDI
 */
#include <Display.h>
#include <FAT.h>
#include <Interpreter.h>
#include <Keyboard.h>
#include <MBR.h>
#include <NCO.h>
#include <SD_Card.h>
#include <Serial_Port.h>
#include <Shared_Buffer.h>
#include <Sound.h>
#include <SPI.h>
#include <stdio.h>
#include <string.h>
#include <xc.h>

//-------------------------------------------------------------------------------------------------
// Microcontroller configuration
//-------------------------------------------------------------------------------------------------
// CONFIG1L register
#pragma config RSTOSC = HFINTOSC_64MHZ, FEXTOSC = OFF  // Use the internal oscillator at 64MHz on reset, disable external oscillator
// CONFIG1H register
#pragma config FCMEN = OFF, CSWEN = ON, PR1WAY = OFF, CLKOUTEN = OFF // Disable Fail-Safe Clock Monitor, allow writing to the OSCCON register to change the oscillator settings, allow the DMA priority bit PRLOCK to be written several times, disable the CLKOUT feature
// CONFIG2L register
#pragma config BOREN = SBORDIS, LPBOREN = OFF, IVT1WAY = OFF, MVECEN = ON, PWRTS = PWRT_64, MCLRE = EXTMCLR // Always enable the Brown-out Reset, disable Low Power Brown-out Reset, IVTLOCK bit can be cleared and set repeatedly, enable interrupts vector table, configure the Power-up timer to 64ms, enable /MCLR
// CONFIG2H register
#pragma config XINST = OFF, DEBUG = OFF, STVREN = ON, PPS1WAY = OFF, ZCD = OFF, BORV = VBOR_2P85 // Disable Extended Instruction Set (it is not yet supported by the compiler), disable the Background debugger, reset on stack overflow or underflow, PPSLOCK bit can be set and cleared repeatedly, disable the unused Zero-cross Detection module, set the Brown-out voltage to the highest available (2.85V)
// CONFIG3L register
#pragma config WDTE = OFF // Disable the Watchdog timer
// CONFIG3H register
#pragma config WDTCCS = SC, WDTCWS = WDTCWS_7 // Set default values (all '1') as the watchdog timer is not used
// CONFIG4L register
#pragma config WRTAPP = OFF, SAFEN = OFF, BBEN = OFF // Allow writing to the Application Block, disable the Storage Area Flash, disable the Boot Block
// CONFIG4H register
#pragma config LVP = ON, WRTSAF = OFF, WRTD = OFF, WRTC = ON, WRTB = OFF // Enable Low-Voltage Programming to avoid needing to apply a high voltage on the /MCLR pin during programming, Storage Area Flash is not write-protected, Data EEPROM is not write-protected, Configuration Registers are write-protected, Boot Block is not write-protected
// CONFIG5L
#pragma config CP = OFF // Disable program and data code protection

//-------------------------------------------------------------------------------------------------
// Private constants
//-------------------------------------------------------------------------------------------------
/** Set to 1 to enable the log messages, set to 0 to disable them. */
#define MAIN_IS_LOGGING_ENABLED 1

//-------------------------------------------------------------------------------------------------
// Private variables
//-------------------------------------------------------------------------------------------------
const unsigned char Main_Splash_Screen[] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFE, 0x00,
	0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x80,
	0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xC0,
	0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xC0,
	0x01, 0xE0, 0x00, 0x00, 0x78, 0x01, 0xC0, 0x78, 0x0F, 0xFF, 0x80, 0x00, 0x01, 0xF0, 0x03, 0xE0,
	0x01, 0xE0, 0x00, 0x00, 0x78, 0x01, 0xC0, 0x78, 0x0F, 0xFF, 0xC0, 0x00, 0x01, 0xE0, 0x01, 0xE0,
	0x01, 0xE0, 0x00, 0x00, 0x78, 0x01, 0xC0, 0x78, 0x0F, 0xFF, 0xE0, 0x00, 0x01, 0xE0, 0x01, 0xE0,
	0x01, 0xE0, 0x00, 0x00, 0x78, 0x01, 0xC0, 0x78, 0x0F, 0x00, 0xF0, 0x00, 0x01, 0xE0, 0x01, 0xE0,
	0x01, 0xE0, 0x00, 0x00, 0x78, 0x01, 0xC0, 0x78, 0x0F, 0x00, 0x70, 0x00, 0x01, 0xF0, 0x03, 0xC0,
	0x01, 0xE0, 0x00, 0x00, 0x78, 0x01, 0xC0, 0x78, 0x0F, 0x00, 0x70, 0x00, 0x00, 0xFF, 0xFF, 0xC0,
	0x01, 0xE0, 0x00, 0x00, 0x78, 0x01, 0xC0, 0x78, 0x0F, 0x00, 0x70, 0x00, 0x00, 0xFF, 0xFF, 0xC0,
	0x01, 0xE0, 0x00, 0x00, 0x7F, 0xFF, 0xC0, 0x78, 0x0F, 0x00, 0xF0, 0xFF, 0x80, 0xFF, 0xFF, 0xC0,
	0x01, 0xE0, 0x00, 0x00, 0x7F, 0xFF, 0xC0, 0x78, 0x0F, 0x7F, 0xE0, 0xFF, 0x81, 0xF0, 0x03, 0xE0,
	0x01, 0xE0, 0x00, 0x00, 0x7F, 0xFF, 0xC0, 0x78, 0x0F, 0x7F, 0xE0, 0xFF, 0x81, 0xE0, 0x01, 0xE0,
	0x01, 0xE0, 0x00, 0x00, 0x78, 0x01, 0xC0, 0x78, 0x0F, 0x7F, 0x80, 0x00, 0x01, 0xE0, 0x01, 0xE0,
	0x01, 0xE0, 0x00, 0x00, 0x78, 0x01, 0xC0, 0x78, 0x0F, 0x00, 0x00, 0x00, 0x01, 0xE0, 0x01, 0xE0,
	0x01, 0xE0, 0x00, 0x00, 0x78, 0x01, 0xC0, 0x78, 0x0F, 0x00, 0x00, 0x00, 0x01, 0xF0, 0x03, 0xE0,
	0x01, 0xFF, 0xFF, 0xC0, 0x78, 0x01, 0xC0, 0x78, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xC0,
	0x01, 0xFF, 0xFF, 0xE0, 0x78, 0x01, 0xC0, 0x78, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xC0,
	0x01, 0xFF, 0xFF, 0xE0, 0x78, 0x01, 0xC0, 0x78, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x80,
	0x00, 0xFF, 0xFF, 0xC0, 0x78, 0x01, 0xC0, 0x78, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFE, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x60, 0x00, 0xFF, 0xE1, 0x80, 0xC1, 0xFC, 0x0F, 0xFE, 0x18, 0x01, 0xFF, 0x00, 0x00,
	0x00, 0x00, 0x60, 0x00, 0xFF, 0xE1, 0xC0, 0xC3, 0xFE, 0x0F, 0xFE, 0x18, 0x01, 0xFF, 0x00, 0x00,
	0x00, 0x00, 0x60, 0x00, 0xC0, 0x61, 0xE0, 0xC3, 0x07, 0x0C, 0x06, 0x18, 0x01, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x60, 0x00, 0xC0, 0x61, 0xF0, 0xC3, 0x00, 0x0C, 0x06, 0x18, 0x01, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x60, 0x00, 0xC0, 0x61, 0xB8, 0xC3, 0xFE, 0x0C, 0x06, 0x18, 0x01, 0xBE, 0x00, 0x00,
	0x00, 0x00, 0x60, 0x00, 0xC0, 0x61, 0x9C, 0xC1, 0xFF, 0x0C, 0x06, 0x18, 0x01, 0xBE, 0x00, 0x00,
	0x00, 0x00, 0x60, 0x00, 0xC0, 0x61, 0x87, 0xC0, 0x03, 0x0C, 0x06, 0x18, 0x01, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x60, 0x00, 0xC0, 0x61, 0x83, 0xC3, 0x03, 0x0C, 0x06, 0x18, 0x01, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xF0, 0xFF, 0xE1, 0x81, 0xC3, 0xFF, 0x0F, 0xFE, 0x1F, 0xF1, 0xFF, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xF0, 0xFF, 0xE1, 0x80, 0xC1, 0xFE, 0x0F, 0xFE, 0x1F, 0xF1, 0xFF, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//-------------------------------------------------------------------------------------------------
// Private functions
//-------------------------------------------------------------------------------------------------
/** Probe the SD card and mount the first FAT partition. */
static void MainMountSDCard(void)
{
	static unsigned char Buffer[SD_CARD_BLOCK_SIZE];
	TMBRPartitionData Partitions_Data[MBR_PRIMARY_PARTITIONS_COUNT], *Pointer_Partitions_Data;
	unsigned char i, Is_Message_Displayed;
	TSDCardDetectionStatus Card_Detection_Status;

	// Wait for an SD card to be inserted
Detect_SD_Card:
	Is_Message_Displayed = 0;
	while (1)
	{
		Card_Detection_Status = SDCardGetDetectionStatus();
		if (Card_Detection_Status != SD_CARD_DETECTION_STATUS_NO_CARD) break;

		// Avoid redrawing the message at each loop
		if (!Is_Message_Displayed)
		{
			DisplayDrawTextMessage(Shared_Buffer_Display, "SD card", "Please insert a SD\ncard.");
			Is_Message_Displayed = 1;
		}
	}

	// The card has not changed and was already probed, nothing more to do
	if (Card_Detection_Status == SD_CARD_DETECTION_STATUS_DETECTED_NOT_REMOVED)
	{
		SERIAL_PORT_LOG(MAIN_IS_LOGGING_ENABLED, "The card has not changed and was already probed.");
		return;
	}

	// Probe the SD card
	if (SDCardProbe() != 0)
	{
		SERIAL_PORT_LOG(MAIN_IS_LOGGING_ENABLED, "\033[31mFailed to probe the SD card.\033[0m");
		DisplayDrawTextMessage(Shared_Buffer_Display, "SD card", "Failed to probe the\nSD card.\nInsert another SD\ncard and press Menu.");
		while (!KeyboardIsMenuKeyPressed());
		__delay_ms(1000); // Give some time to the SD card to wake up
		goto Detect_SD_Card;
	}

	// The first SD card block contains the MBR, get it
	if (SDCardReadBlock(0, Buffer) != 0)
	{
		SERIAL_PORT_LOG(MAIN_IS_LOGGING_ENABLED, "Failed to read the SD card MBR block.");
		DisplayDrawTextMessage(Shared_Buffer_Display, "SD card", "Failed to read the SDcard MBR block.\nInsert another SD\ncard and press Menu.");
		while (!KeyboardIsMenuKeyPressed());
		__delay_ms(1000); // Give some time to the SD card to wake up
		goto Detect_SD_Card;
	}

	// Find the first valid primary partitions (do not care about the partition type, as it does not reflect the real file system the partition is formatted with)
	MBRParsePrimaryPartitions(Buffer, Partitions_Data);
	for (i = 0; i < MBR_PRIMARY_PARTITIONS_COUNT; i++)
	{
		// Cache the partition data access
		Pointer_Partitions_Data = &Partitions_Data[i];
		SERIAL_PORT_LOG(MAIN_IS_LOGGING_ENABLED, "Partition %d : type=0x%02X, start sector=%lu, sectors count=%lu.", i + 1, Pointer_Partitions_Data->Type, Pointer_Partitions_Data->Start_Sector, Pointer_Partitions_Data->Sectors_Count);

		// Bypass any empty partition
		if (Pointer_Partitions_Data->Type == 0)
		{
			SERIAL_PORT_LOG(MAIN_IS_LOGGING_ENABLED, "Partition is empty, trying next one.");
			continue;
		}

		// Try to mount the file system as the partition is not empty
		if (FATMount(Pointer_Partitions_Data) != 0)
		{
			SERIAL_PORT_LOG(MAIN_IS_LOGGING_ENABLED, "Failed to mount the partition %d.", i + 1);
			continue;
		}
		SERIAL_PORT_LOG(MAIN_IS_LOGGING_ENABLED, "Partition %d was successfully mounted.", i + 1);
		break;
	}
	// Were all partitions invalid ?
	if (i == MBR_PRIMARY_PARTITIONS_COUNT)
	{
		SERIAL_PORT_LOG(MAIN_IS_LOGGING_ENABLED, "No valid partition could be found.");
		DisplayDrawTextMessage(Shared_Buffer_Display, "SD card", "No valid partition\ncould be found.\nInsert another SD\ncard and press Menu.");
		while (!KeyboardIsMenuKeyPressed());
		goto Detect_SD_Card;
	}
}

//-------------------------------------------------------------------------------------------------
// Entry point
//-------------------------------------------------------------------------------------------------
void main(void)
{
	unsigned char a = '0';
	TFATFileInformation File_Information, File_Information_2;

	// Wait for the internal oscillator to stabilize
	while (!OSCSTATbits.HFOR);

	// TEST
	ANSELBbits.ANSELB0 = 0;
	LATBbits.LATB0 = 1;
	TRISBbits.TRISB0 = 0;

	// Initialize all needed modules
	SerialPortInitialize();
	NCOInitialize(); // This module must be initialized before the sound module
	SoundInitialize();
	KeyboardInitialize();
	InterpreterInitialize();
	SDCardInitialize();
	SPIInitialize(); // The SPI module must be initialized before the display
	DisplayInitialize();
	SDCardInitialize();

	// Show the splash screen
	memcpy(Shared_Buffer_Display, Main_Splash_Screen, sizeof(Shared_Buffer_Display));
	DisplayDrawFullSizeBuffer(Shared_Buffer_Display);
	__delay_ms(2000);

	// Initialize the interrupts
	// Set the vector table base address to the default value
	IVTBASEU = 0;
	IVTBASEH = 0;
	IVTBASEL = 0x08;
	// Enable interrupts
	INTCON0bits.IPEN = 0; // Disable priority, all interrupts are high-priority and use the hardware order
	INTCON0bits.GIE = 1; // Enable all interrupts

	// Block until an SD card with a valid FAT file system is inserted
	MainMountSDCard();

	// TEST
	SerialPortWriteString("\033[33m#######################################\033[0m\r\n");

	// TEST
	if (FATListStart("/") != 0)
	{
		SERIAL_PORT_LOG(MAIN_IS_LOGGING_ENABLED, "FATListStart() failed");
	}
	while (FATListNext(&File_Information) == 0)
	{
		printf("File found : name=\"%s\", is directory=%u, size=%lu, first cluster=%lu.\r\n",
			File_Information.String_Short_Name,
			File_Information.Is_Directory,
			File_Information.Size,
			File_Information.First_Cluster_Number);

		if (strcmp((char *) File_Information.String_Short_Name, "PROTOC~1.TXT") == 0)
		{
			printf("Found test file to load.\r\n");
			memcpy(&File_Information_2, &File_Information, sizeof(File_Information));
		}
	}

	// TEST
	InterpreterLoadProgramFromFile(&File_Information_2);
	InterpreterRunProgram();

	SerialPortWriteString("\033[35m@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\033[0m\r\n");

	while (1)
	{
		LATBbits.LATB0 = !LATBbits.LATB0;

		__delay_ms(1000);
	}
}
